# L36 - The `static` Keyword

Source: `L36_static_keyword/StaticKeywordDemo.java`

## 1. Definition & Core Idea
`static` ties a member (field, method, block, nested class) to the class itself instead of to individual instances. Loaded once per class (per ClassLoader). All instances share the same static state.

## 2. Where You Can Use `static`
| Context | Example | Purpose |
|---------|---------|---------|
| Field | `static int count;` | Shared state / constants |
| Method | `static int add(int a,int b)` | Utility / factory / helper |
| Initializer Block | `static { ... }` | One-time class setup logic |
| Nested Class | `static class Helper {}` | Namespacing without outer instance |
| Import (static import) | `import static java.lang.Math.*;` | Use members without qualifying class |

Notes:
- You cannot mark local variables as static (inside methods) in standard Java.
- Top-level classes cannot be static (only nested classes can be static).

## 3. Common Use Cases
| Use Case | Pattern | Rationale |
|----------|--------|-----------|
| Constants | `public static final int MAX = 10;` | Single canonical value; no duplication |
| Utility Methods | `Math.max(a,b)` | Stateless helpers; no need to create objects |
| Caches / Registries | `static Map<String,Thing> CACHE` | Application-wide shared lookup |
| Counters / Metrics | `static long created;` | Track creation counts globally |
| Factories | `public static User of(String name)` | Expressive naming, validation, caching possibility |
| Static Nested Helper | `Outer.StaticNested` | Encapsulate helper logic, access outer's statics |
| One-Time Init | `static { loadConfig(); }` | Defer heavy work until first use |

## 4. Rules to Follow
1. Static members belong to the class, accessed via `ClassName.member` (preferred).  
2. Instance methods CAN access static members, but static methods CANNOT access instance members without an object reference.  
3. `this` and `super` are not allowed in static context.  
4. Initialization order: static fields → static blocks (in textual order) → instance fields → constructor.  
5. Avoid modifying mutable static state concurrently without synchronization.  
6. Do not overuse static for convenience; it can create hidden coupling.  
7. A `static final` reference points to the same object; if the object is mutable, its internal state can still change (use immutable types).  
8. Circular static initialization can produce `null` or default values (avoid interdependent static initializers).  
9. Static nested classes do not hold an implicit reference to the outer instance (unlike non-static inner classes).  
10. Minimize side effects in static blocks (log or initialize; avoid complex logic where possible).  

## 5. Best Practices & Guidelines
| Guideline | Why |
|-----------|-----|
| Prefer constants as `public static final` with UPPER_SNAKE_CASE | Conventional clarity |
| Avoid exposing mutable static collections directly | Prevent external uncontrolled mutation |
| Use utility classes with private constructors | Prevent accidental instantiation |
| Keep static blocks small; extract logic into private static methods | Readability & testability |
| Consider dependency injection over large static registries | Improves testability & modularity |
| Use static factories when naming or pre-processing adds value | Cleaner than telescoping constructors |
| Favor composition over static access for behavior that may need variation | Extensibility/testing |
| Document thread-safety of static mutable state | Avoid race conditions |

## 6. Choosing `static` or Not
Ask: Is this behavior/state inherently global and invariant per instance? If yes, static may be appropriate. If behavior depends on unique per-object state or should be polymorphic, keep it non-static.

## 7. Static vs Instance Methods
| Aspect | Static | Instance |
|--------|--------|----------|
| Dispatch | Compile-time | Virtual (dynamic) |
| Needs Object State | No | Yes |
| Overridable | No (can hide) | Yes |
| Common Use | Utilities, factories | Domain behavior |

## 8. Static Nested Classes vs Inner Classes
| Static Nested | Inner (Non-static) |
|---------------|-------------------|
| No outer instance required | Requires an outer instance |
| Cannot access outer instance fields directly | Has implicit `Outer.this` reference |
| Lower memory overhead | Slight overhead (captures outer) |
| Use for grouping helpers | Use when behavior tied to specific outer instance |

## 9. Mini Practice
1. Convert a utility instance method to static and remove the need to instantiate.  
2. Add a static counter to a class and print how many objects are created.  
3. Write a static factory returning a trimmed, validated value object.  
4. Create a static nested helper class and call its method.  
5. Refactor a large static block into smaller private static methods.  

## 10. Pitfalls
| Pitfall | Problem | Remedy |
|---------|---------|--------|
| Global mutable state | Hard to reason/test | Encapsulate / make immutable |
| Hidden coupling via static calls | Tight inter-module dependency | Inject interfaces or pass collaborators |
| Static initializer throwing exception | `ExceptionInInitializerError` halts class loading | Keep logic simple & fail fast with clear message |
| Using static where polymorphism needed | Inflexible design | Use instance methods / interfaces |
| Accessing instance fields from static | Compile error / confusion | Pass instance as parameter |

## 11. Key Takeaways
`static` is for class-level, shared, or globally reusable aspects: constants, utilities, simple factories, and one-time initialization. Use deliberately; avoid turning your codebase into a sea of global state.

```java
public class Example {
    public static final double PI = 3.14159; // constant
    private static int created;              // counter

    public Example() { created++; }

    public static int createdCount() { return created; }

    public static Example of() { return new Example(); }
}
```

See code in `L36_static_keyword/StaticKeywordDemo.java` for runnable illustrations.
