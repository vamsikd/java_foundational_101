# L61: Threads — creation, use cases, rules, and best practices

This lesson introduces Java threads from the ground up: how to create them, coordinate them, avoid common pitfalls, and follow pragmatic best practices.

## What you will learn
- Create threads via: extend `Thread`, implement `Runnable`, lambda `Runnable`.
- Coordinate with `start()`, `join()`, `sleep()`, and interrupts.
- Understand race conditions and how `synchronized` fixes visibility and atomicity.
- Know when to use daemon threads.

## 1) Threads in Java
A thread is an independent path of execution within a process. The JVM starts your program with one thread — `main`. New threads run code concurrently (true parallelism depends on CPU cores and the JVM).

### Ways to create
- Extend `Thread` and override `run()` — simple, but couples task with thread.
- Implement `Runnable` and pass to `new Thread(runnable)` — preferred. Decouples task from execution strategy.
- Lambda as `Runnable` — concise for small tasks.

See: `L61_threads/ThreadsDemo.java` (section: threadCreationExamples).

## 2) Coordination: start, join, sleep
- `start()` — begins execution; calls the thread's `run()` on another thread.
- `join()` — caller waits until the target thread finishes.
- `sleep(ms)` — pause the current thread (can throw `InterruptedException`).

Tip: Always consider what the main thread should do while workers run, and when to wait for them.

## 3) Race Conditions and Synchronization
When multiple threads access and modify shared state without proper coordination, outcomes become nondeterministic.

- Data race example: incrementing a shared `int` without synchronization.
- Fix: `synchronized` methods/blocks ensure mutual exclusion and establishes happens-before ordering.
- Alternative tools (beyond this intro): `java.util.concurrent.atomic` (e.g., `AtomicInteger`) and locks.

In the demo, compare `UnsafeCounter` and `SafeCounter` results.

## 4) Interrupts (Cooperative Cancellation)
- Interrupts are a polite request to stop; they don't forcibly kill threads.
- Blocked methods like `sleep`, `wait`, and many I/O operations react to interrupts by throwing `InterruptedException`.
- Typical pattern: catch, handle/cleanup, and either re-set the interrupt flag or propagate.

See demo method `interruptExample`.

## 5) Daemon Threads
- Daemon threads are background helpers. JVM does not wait for them at shutdown if only daemons remain.
- Use for housekeeping tasks; avoid for critical work that must complete.

## 6) Uses and Use Cases
- Offloading slow operations (I/O, network) from the main thread.
- Parallelizing independent computations.
- Background maintenance (cache refresh, telemetry batching).
- Responsive UIs: keep UI thread free (Swing/JavaFX).

## 7) Rules to Follow
- Keep shared state minimal; prefer immutable data.
- If sharing mutable state, use synchronization or concurrency primitives.
- Never call `run()` directly to start a thread — use `start()`.
- Avoid busy waiting; prefer `wait/notify`, `join`, or higher-level constructs.
- Always handle `InterruptedException` thoughtfully (propagate or re-set flag).
- Name threads for easier debugging: `new Thread(r, "Worker-1")`.

## 8) Best Practices & Guidelines
- Prefer high-level executors (thread pools) from `java.util.concurrent` for real apps.
- Keep tasks small and focused; avoid long-held locks.
- Log or print concise, deterministic progress for learning and debugging.
- For counters/flags, consider `Atomic*` classes or `volatile` when appropriate.
- Test with different iteration counts to expose races in examples.

## 9) Try it
Compile and run this lesson:
```pwsh
javac .\L61_threads\ThreadsDemo.java
java L61_threads.ThreadsDemo
```

Expected output (approximate, order may vary for creation section):
```
=== L61: Threads Demo ===
-- Creation: extends Thread, implements Runnable, lambda Runnable --
[MyThread] running on Thread-0
[MyTask] running on Thread-1
[LambdaTask] running on Thread-2
-- Join: wait for a worker to finish --
[JoinWorker] started
[JoinWorker] finished
[main] after join
-- Race condition vs synchronized --
[UnsafeCounter] expected=10000, actual=<may be < 10000>
[SafeCounter] expected=10000, actual=10000
-- Interrupts: cooperative cancellation --
[Interruptible] going to sleep
[Interruptible] interrupted during sleep
[main] interrupt demo done
-- Daemon threads --
[Daemon] background tick
[main] daemon demo done
=== End of Threads Demo ===
```

Source: `L61_threads/ThreadsDemo.java`.
