# L51 - Exceptions

Source: `L51_exceptions/ExceptionsDemo.java`

## 1. What Is an Exception?
An exception is an event that disrupts normal program flow. In Java it is an object thrown to signal error or exceptional conditions. Handling allows recovery, cleanup, or graceful failure.

## 2. Hierarchy & Types
```
Throwable
 ├─ Error (serious, generally unrecoverable: OutOfMemoryError)
 └─ Exception
     ├─ RuntimeException (unchecked)
     │    e.g. NullPointerException, IllegalArgumentException
     └─ (checked) e.g. IOException, SQLException
```
| Category | Propagation Requirement | Examples | Guidance |
|----------|------------------------|----------|----------|
| Checked | Must be declared or caught | IOException | Represent recoverable conditions |
| Unchecked (Runtime) | No declaration needed | NullPointerException | Programming errors / precondition violations |
| Error | Do not catch normally | OutOfMemoryError | JVM/internal issues |

## 3. Use Cases
| Scenario | Exception Usage |
|----------|-----------------|
| Input validation failure | Throw IllegalArgumentException / custom ValidationException |
| Resource I/O issue | Propagate / wrap IOException |
| Business rule violation | Custom checked or unchecked domain exception |
| Aggregating lower causes | Wrap and rethrow with context |
| Early exit on invalid state | Throw IllegalStateException |

## 4. Rules
1. Checked exceptions must be declared with `throws` or handled in a `try-catch`.  
2. Unchecked exceptions extend `RuntimeException`; no `throws` needed.  
3. Always release resources (try-with-resources or finally).  
4. Catch only what you can handle; rethrow otherwise.  
5. Order catch blocks from most specific to most general.  
6. Never swallow exceptions silently.  
7. Preserve root cause (use constructor with `cause`).  
8. Avoid using exceptions for normal control flow (performance & clarity).  
9. Do not catch `Error` types except to log and terminate.  
10. Include contextual info in message (input values, state) without leaking secrets.  

## 5. Best Practices
| Practice | Benefit |
|----------|---------|
| Use meaningful custom exception names | Faster diagnosis |
| Wrap low-level exceptions at boundaries | Layer abstraction clarity |
| Provide actionable messages | Simplifies debugging |
| Fail fast with clear validation | Prevents cascading errors |
| Prefer unchecked for programmer errors | Reduces boilerplate |
| Limit broad catch (Exception) | Avoid hiding defects |
| Use multi-catch for related handling | DRY code |
| Utilize try-with-resources | Automatic cleanup |

## 6. Try-With-Resources
```java
try (BufferedReader br = Files.newBufferedReader(path)) {
  return br.readLine();
} // auto-close
```
Objects must implement `AutoCloseable`.

## 7. Wrapping & Rethrowing
```java
try { dao.save(x); } catch (SQLException e) {
  throw new RepositoryException("Save failed id=" + x.id(), e);
}
```
Preserves cause chain for diagnostics.

## 8. Custom Exception Template
```java
public class ValidationException extends RuntimeException {
  public ValidationException(String msg) { super(msg); }
  public ValidationException(String msg, Throwable cause) { super(msg, cause); }
}
```

## 9. Common Pitfalls
| Pitfall | Issue | Fix |
|---------|-------|-----|
| Swallowing exception | Silent failure | Log or rethrow |
| Overusing checked exceptions | Boilerplate noise | Use runtime for programming errors |
| Exposing internal stack traces to users | Security/info leak | Map to friendly message |
| Large catch(Exception) blocks | Hide defects | Narrow scope |
| Returning partial state after failure | Data inconsistency | Roll back or fail fast |

## 10. Mini Practice
1. Add a custom `NegativeValueException` and throw on negative input.  
2. Convert a manual resource close to try-with-resources.  
3. Wrap an `ArithmeticException` with a domain `CalculationException`.  
4. Demonstrate rethrow with additional context message.  
5. Add a method that throws multiple checked exceptions and use multi-catch.  

## 11. Key Takeaways
Use exceptions to signal abnormal conditions, not for regular branching. Keep handling localized, messages rich, and causes preserved.

See `L51_exceptions/ExceptionsDemo.java` for runnable examples.
