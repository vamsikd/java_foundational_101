# L53: `throw` vs `throws`

In this lesson we focus on two related but distinct keywords:
- `throw` – actually creates and launches an exception object at a specific line.
- `throws` – appears in a method (or constructor) signature to declare that the method may propagate one or more checked exceptions to its caller.

## 1. `throw`
`throw new SomeException("message");` transfers control immediately to the nearest matching `catch` (or unwinds the stack if not caught). After a `throw`, the rest of the statements in that block are skipped.

Typical uses:
- Input validation (fail fast).
- Converting/wrapping lower-level exceptions.
- Signalling unsupported operations.

## 2. `throws`
Placed after the parameter list in a method signature: `void read() throws IOException`. It is a compile‑time contract for CHECKED exceptions (subclasses of `Exception` excluding `RuntimeException`). Unchecked exceptions do not need to be declared (you *can* list them, but it adds noise).

Rules (simplified):
1. If a method can throw a checked exception and does not handle it, it must declare it with `throws`.
2. Overriding methods may declare fewer or narrower checked exceptions, but not broader / additional new checked ones.
3. Constructors follow the same rules as methods.

## 3. Checked vs Unchecked Recap
- Checked examples: `IOException`, `SQLException` – caller must handle or declare.
- Unchecked examples: `NullPointerException`, `IllegalArgumentException`, custom subclasses of `RuntimeException` – caller not forced to handle.

## 4. Rethrowing & Wrapping
You can catch a checked exception, add context, then throw a new one, preserving the original as the cause:
```java
catch (IOException e) {
    throw new IOException("Higher-level operation failed", e);
}
```
This keeps the root cause in the stack trace while adding semantic meaning.

## 5. Custom Exceptions
- Extend `Exception` for a checked custom type (forces handling when thrown).
- Extend `RuntimeException` for an unchecked type (use sparingly for programmer errors or invariants).

## 6. Common Patterns
| Scenario | Pattern |
|----------|---------|
| Validate arguments | `if (arg <= 0) throw new IllegalArgumentException("must be > 0");` |
| Wrap low-level | `throw new ServiceException("db failed", e);` |
| Add context & rethrow | Catch -> new exception with cause |
| Early exit | Throw immediately instead of nested conditionals |

## 7. Pitfalls
| Pitfall | Why it hurts |
|---------|--------------|
| Declaring unchecked exceptions in `throws` | Noise, no enforcement benefit |
| Swallowing then throwing unrelated | Loses original cause; breaks debugging |
| Overusing checked exceptions | Leads to cluttered signatures |
| Throwing broad (`Exception`) | Hides specific intent |

## 8. Best Practices
- Use checked exceptions for recoverable conditions the caller *should* address.
- Use unchecked for programming errors (violated preconditions, invariants).
- Fail fast with clear, actionable messages.
- Preserve causes when adding context.
- Keep signatures clean: don't leak internal technology-specific exceptions; wrap them.

## 9. Run the Demo
Compile & run only this lesson (Windows PowerShell):
```pwsh
javac .\L53_throw_throws\ThrowThrowsDemo.java
java L53_throw_throws.ThrowThrowsDemo
```

Output (approximate):
```
=== throw vs throws Demo ===
Validation caught: String must be non-blank
Handled checked IOException: simulated IO failure
Wrapped & rethrown caught: Higher-level operation failed
Cause: java.io.IOException: simulated IO failure
NetworkClient send failed: data too short
Caught CustomUnchecked: runtime problem
Caught CustomChecked: checked problem
```

See the source file: `L53_throw_throws/ThrowThrowsDemo.java`.
