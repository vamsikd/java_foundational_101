# L41 - Interfaces

Source: `L41_interfaces/InterfacesDemo.java`

## 1. Definition
An interface declares a contract (set of abstract methods and constants) that implementing classes agree to fulfill. Modern Java interfaces can also contain default, static, and private methods (Java 9+) for shared behavior and helpers.

## 2. Interface Members
| Member Type | Implicit Modifiers | Notes |
|-------------|--------------------|-------|
| Field | public static final | Constants only (UPPER_SNAKE_CASE) |
| Abstract method | public abstract | Must be implemented (unless default provided) |
| Default method | public | Provides inheritable implementation |
| Static method | public | Namespaced utility, not inherited polymorphically |
| Private method | private | Helper for default/static methods |

## 3. Use Cases
| Scenario | Interface Fit | Reason |
|----------|---------------|-------|
| Multiple unrelated implementations | Strong | Promotes polymorphism |
| Capability grouping (e.g., Serializable) | Strong | Marker or behavioral grouping |
| Mix multiple behaviors into one class | Strong | Multiple inheritance of type |
| Sharing stateful code | Weak | Use abstract class instead |
| Large evolving API needing compatibility | Moderate | Use default methods cautiously |

## 4. Rules
1. All interface fields are implicitly `public static final`.
2. All non-static, non-default methods are implicitly `public abstract`.
3. A class can implement multiple interfaces; methods must resolve any signature conflicts.
4. Default method conflicts require explicit override with choice (e.g., `A.super.method()`).
5. Static interface methods are not inherited; call with `InterfaceName.method()`.
6. Interfaces cannot have instance fields (only constants).
7. A functional interface has exactly one abstract method; may include default/static methods.
8. Private methods support code reuse inside the interface (not visible externally).
9. Do not rely on field shadowing—constants are effectively inlined at compile time.

## 5. Best Practices
| Practice | Benefit |
|----------|---------|
| Keep interfaces small & focused (ISP principle) | Low coupling |
| Prefer composition over bloated "god" interfaces | Maintainability |
| Use default methods sparingly (backwards compatibility) | Avoid complexity |
| Name functional interfaces with verbs (e.g., `Processor`) | Express intent |
| Prefer enums for fixed sets over marker interfaces | Clarity |
| Document thread-safety expectations in contract | Consistency |
| Avoid exposing constants unrelated to behavior | Cohesion |

## 6. Multiple Inheritance & Conflict Resolution
If two interfaces provide the same default method signature, the implementing class must override and optionally delegate via `X.super.method()` to one or both.

## 7. Functional Interfaces
Marked with `@FunctionalInterface` (optional but helpful) to enforce a single abstract method. Enables lambda & method reference usage.

```java
@FunctionalInterface
interface Action { void run(String msg); }
Action a = m -> System.out.println(m);
```

## 8. Interface vs Abstract Class
| Aspect | Interface | Abstract Class |
|--------|----------|----------------|
| Fields | Constants only | Any (stateful) |
| Inheritance | Multiple allowed | Single |
| Constructors | No | Yes |
| Default Implementation | default methods | Concrete & abstract methods |
| When to choose | Capability contract | Shared state + partial impl |

## 9. Pitfalls
| Pitfall | Issue | Fix |
|---------|-------|-----|
| Overusing default methods | Logic duplication across hierarchy | Refactor to helper/abstract class |
| Large multi-purpose interface | Hard to implement & test | Split into smaller interfaces |
| Exposing mutable objects via constants | Caller can mutate | Return unmodifiable / immutable |
| Relying on constant values across modules | Inlining risk | Version carefully / use accessor |
| Ignoring conflict resolution | Ambiguity | Explicit override |

## 10. Mini Practice
1. Add a `Disconnectable` interface and implement in `SmartPhone`.
2. Convert an anonymous class implementing `Action` to a lambda.
3. Introduce a conflict between two default methods and resolve it.
4. Create a functional interface and use a method reference.
5. Replace a class hierarchy with an interface + multiple implementations.

## 11. Key Takeaways
Interfaces define WHAT (capabilities), not HOW (state). Use them to enable polymorphism, decouple components, and compose behaviors. Default and static methods add convenience—use them judiciously to keep contracts clean.

See `L41_interfaces/InterfacesDemo.java` for runnable examples.
