# L38 - Wrapper Classes

Source: `L38_wrapper_classes/WrapperClassesDemo.java`

## 1. Definition
Wrapper classes provide object representations of primitive types so primitives can participate in APIs that require objects (collections, generics, reflection). Each primitive has a corresponding wrapper:
- byte → Byte
- short → Short
- int → Integer
- long → Long
- float → Float
- double → Double
- char → Character
- boolean → Boolean

## 2. Usage & Core Concepts
| Concept | Example | Notes |
|---------|---------|-------|
| Boxing | `Integer x = 5;` | Auto-converts primitive to wrapper |
| Unboxing | `int y = x;` | Auto-converts wrapper to primitive (may NPE if null) |
| valueOf caching | `Integer.valueOf(42)` | Reuses cached objects for small values |
| Parsing | `Integer.parseInt("123")` | Returns primitive; throws NumberFormatException on bad input |
| Constants | `Integer.MAX_VALUE` | Min/Max boundaries |
| Utility | `Double.isNaN(v)` | Classification helpers |
| Character helpers | `Character.isDigit(c)` | Unicode-aware checks |
| Boolean parsing | `Boolean.parseBoolean("true")` | Case-insensitive, non-true → false |

## 3. Common Use Cases
| Use Case | Wrapper Role | Reason |
|----------|-------------|-------|
| Collections | `List<Integer>` | Generics require reference types |
| Nullable values | `Integer maybe;` | Represent absence vs 0 |
| Generic algorithms | Reflection / frameworks | Uniform object handling |
| Caching small numbers | Integer cache | Reduced allocations |
| Numeric conversions | `Integer.valueOf(String)` | Input parsing |
| Utility / classification | `Character.isLetter(ch)` | Unicode correctness |

## 4. Rules & Behaviors
1. Auto-boxing/unboxing is compiler syntactic sugar; can allocate & throw NPE.  
2. Integer, Short, Byte, Long, Character cache values in range -128..127 (Character 0..127).  
3. Use `equals` for value equality; `==` only checks reference identity (may appear true within cache range).  
4. Parsing methods (`parseInt`, etc.) throw `NumberFormatException` on invalid input; `valueOf` wraps parse then boxes.  
5. Floating point wrappers follow IEEE 754: `NaN`, `Infinity`, `-0.0` behaviors preserved.  
6. Wrapper objects are immutable (state cannot change).  
7. Unboxing a null reference throws `NullPointerException`.  
8. Repeated boxing in tight loops impacts performance (prefer primitives).  
9. Boolean parsing: only case-insensitive "true" yields true; everything else → false.  
10. Avoid `new Integer(...)` / `new Long(...)`; constructors are deprecated in modern Java.  

## 5. Best Practices
| Practice | Benefit |
|----------|---------|
| Prefer primitives in performance-critical code | Avoid allocation/boxing cost |
| Use wrappers only when nullability or generics needed | Clarity of intent |
| Rely on `valueOf` / literals for boxing | Leverage caches |
| Always null-check before unboxing | Prevent NPE |
| Use `equals`, not `==` (except deliberate cache/check identity) | Correct semantics |
| Treat wrappers as immutable & thread-safe | Safe to share |
| Consider Optional for nullable semantics | Explicit absence |
| Avoid mixing boxed and primitive in arithmetic | Prevent unexpected boxing chains |

## 6. Choosing Primitive vs Wrapper
| Need | Choose |
|------|--------|
| High performance numeric loop | primitive |
| Nullable field | wrapper / Optional |
| Collection element | wrapper |
| Generic method parameter | wrapper |
| Interop with legacy API requiring object | wrapper |

## 7. Pitfalls
| Pitfall | Issue | Fix |
|---------|-------|-----|
| Unboxing null | NPE | Check for null / default |
| Using == for equality | Reference mismatch | Use equals |
| Excess boxing in loops | Performance hit | Use primitive accumulator |
| Assuming cache for all values | Identity fails outside range | Don't rely on identity |
| Deprecated constructors | Noise / no caching | Use valueOf / literals |

## 8. Performance Illustration
Using a Wrapper accumulator in a loop causes repeated boxing/unboxing: `sum += i;` expands to unbox + add + box each iteration. Swap `Long` for `long` to remove overhead.

## 9. Safe Unboxing Helper
```java
int safe = (value != null) ? value : defaultValue;
```
Encapsulate this pattern when handling nullable wrappers from external sources.

## 10. Mini Practice
1. Show cache vs non-cache identity with 127 vs 128.  
2. Parse a string safely with try/catch around `Integer.parseInt`.  
3. Replace a `Long` accumulator with `long` in a loop and compare times.  
4. Write a method accepting `Integer` and returning primitive default.  
5. Demonstrate `equals` vs `==` semantics for cached and non-cached values.  

## 11. Key Takeaways
Wrappers enable primitives to live in the object world—collections, generics, nullability—but introduce overhead and NPE risk. Default to primitives for raw computation and only elevate to wrappers when object semantics are required.

```java
Integer boxed = 10; // boxing
int primitive = boxed; // unboxing
Integer a = 127, b = 127, c = 128, d = 128;
System.out.println(a == b); // true (cache)
System.out.println(c == d); // false
```

See `L38_wrapper_classes/WrapperClassesDemo.java` for runnable examples.
