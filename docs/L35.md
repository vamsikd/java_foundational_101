# L35 - Access Modifiers

Source: `L35_access_modifiers/AccessModifiersDemo.java`

## 1. Purpose
Control visibility of classes, fields, methods, and constructors to enforce encapsulation, define clear APIs, and support safe evolution of code.

## 2. Modifier Levels
| Modifier | Applies To (Top-Level) | Applies To (Members) | Visibility Scope |
|----------|------------------------|----------------------|------------------|
| public | yes | yes | Everywhere (any module / package) |
| (package-private) *(default)* | yes | yes | Same package only |
| protected | no (members only) | yes | Package + subclasses (even in other packages) |
| private | no | yes | Declaring class only |

Notes:
- Top-level classes/interfaces: only public or package-private (omit modifier).
- protected combines package access + inheritance access.

## 3. Typical Use Cases
| Scenario | Recommended Modifier | Rationale |
|----------|----------------------|----------|
| Public API surface (library) | public | External consumption |
| Internal implementation detail | package-private | Hide from consumers |
| Helper for subclass customization | protected | Provide overridable hook |
| Sensitive state / invariants | private + accessors | Validation and encapsulation |
| Narrow factory / construction control | private constructor + public factory | Controlled instantiation |

## 4. Rules & Constraints
1. You cannot reduce visibility when overriding (can keep or widen).
2. A private member is not inherited (it's inaccessible, though present).
3. protected gives two avenues: same package access OR subclass (even different package) through inheritance.
4. Avoid exposing mutable fields directly; prefer private + methods.
5. Only one public top-level class per file (if any); filename must match that class.
6. Interfaces members are implicitly public (methods) / public static final (fields).
7. Nested classes can use any modifier (including private) to encapsulate helpers.

## 5. Design Guidelines & Best Practices
| Guideline | Reason |
|-----------|-------|
| Start restrictive (private/package) then widen only if needed | Prevents accidental API commitment |
| Use package-private for cohesive internal collaboration | Keeps public surface small |
| Prefer composition + private state over protected fields | Reduces fragile base class issues |
| Expose intent with methods, not raw fields | Maintain invariants / flexibility |
| Keep protected methods narrowly focused | Minimize subclass coupling |
| Avoid "everything public" anti-pattern | Hard to refactor later |
| Combine private fields + validating setters/getters | Encapsulation & safety |
| Use records (public components) only for pure data carriers | Clear intent |

## 6. Choosing the Right Modifier (Flow)
1. Can this stay entirely inside one class? -> private.
2. Needed by tightly related classes in same package? -> package-private.
3. Must be customizable by subclasses? -> protected (prefer fine-grained final + small hooks).
4. Needed by outside code? -> public (document & test it!).

## 7. Protected vs Package-Private
- Use protected primarily for well-defined extension points.
- If no subclassing outside package is expected, prefer package-private.
- Overuse of protected increases inheritance-based coupling.

## 8. Mini Practice
1. Convert a public field to private with getter/setter and add validation.
2. Add a protected hook method and override it in a subclass to customize part of an algorithm.
3. Refactor a helper class to package-private to hide it.
4. Try to make a top-level class private (observe compile error) then fix.
5. Create a hierarchy where a subclass in another package accesses a protected method.

## 9. Common Pitfalls
| Pitfall | Issue | Fix |
|---------|-------|-----|
| Exposing mutable fields | External mutation breaks invariants | Keep private, expose copies or methods |
| Overusing protected | Creates brittle inheritance chains | Prefer composition / package-private |
| Public methods with weak contracts | Misuse by callers | Strengthen docs, validate inputs |
| Widening too early | API freeze limits refactors | Delay until stable |
| Mixing access with unrelated responsibilities | Hard to reason about | Separate concerns into packages |

## 10. Key Takeaways
Access modifiers shape your API boundary. Default to the most restrictive visibility that still enables intended use. Widen only with justification, and document public/protected members as part of your contract.

```java
// Quick reference
public class Api { /* open to all */ }
class InternalHelper { /* package-private */ }
class Base { protected void hook() {} }
class Sub extends Base { @Override protected void hook() {} }
```

See `L35_access_modifiers/AccessModifiersDemo.java` for runnable examples.
