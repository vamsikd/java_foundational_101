# L42 - Enums

Source: `L42_enums/EnumsDemo.java`

## 1. Definition
An enum is a special class representing a fixed set of named constants. Each enum constant is a singleton instance. Enums can have fields, constructors, methods, implement interfaces, and define constant‑specific behavior.

## 2. Basic Features
| Aspect | Example | Notes |
|--------|---------|-------|
| Declaration | `enum Day { MONDAY, TUESDAY }` | Implicitly extends `java.lang.Enum` |
| Iterate | `for (Day d : Day.values())` | Values in declaration order |
| Name | `d.name()` | Exact identifier |
| Ordinal | `d.ordinal()` | Zero-based position (avoid for persistence) |
| Parse | `Day.valueOf("MONDAY")` | Throws if not found |
| Custom field | `MONDAY(false)` | Supply to private constructor |
| Switch | `switch(day)` | Exhaustiveness with all constants |

## 3. Use Cases
| Use Case | Why Enums Fit |
|----------|--------------|
| Fixed categories (days, states) | Type safety, limited set |
| Strategy / behavior selection | Constant-specific methods |
| Configuration flags | Replace magic strings/ints |
| State machine | Enumerate states cleanly |
| Command dispatch | Map enum to handler |

## 4. Rules
1. Enum constructors are implicitly private; you cannot `new` an enum outside its declaration.  
2. First line of an enum lists constants; fields/methods follow.  
3. Enum constants are `public static final` instances.  
4. You can define abstract methods and implement them per constant.  
5. `ordinal()` is for internal ordering—don't persist or rely on it across versions.  
6. Enums can implement interfaces but cannot extend classes (already extend `Enum`).  
7. Serialization is handled specially (singleton guarantee).  
8. Avoid storing mutable state that changes across lifecycle (may break assumptions).  
9. No public setters—constants should be logically immutable.  
10. Use `EnumSet` / `EnumMap` for performance & memory efficiency with enums.  

## 5. Best Practices
| Practice | Reason |
|----------|-------|
| Use ALL_CAPS for constants | Consistent with constant naming |
| Prefer methods over `if/else` chains | Polymorphism at constant level |
| Provide a `safeValueOf` wrapper | Avoid try/catch at call sites |
| Avoid `ordinal()` outside internal logic | Future-proofing |
| Group related behavior inside enum | Encapsulation |
| Use switch expressions for clarity | Exhaustive handling |
| Replace int constants with enums | Type safety |

## 6. Constant-Specific Behavior
```java
enum Op {
  ADD { int apply(int a,int b){ return a+b; } },
  MUL { int apply(int a,int b){ return a*b; } };
  abstract int apply(int a,int b);
}
```
Each constant overrides the abstract method.

## 7. Strategy Pattern via Enum
Enums can encapsulate different algorithms:
```java
enum TaxStrategy {
  STANDARD { double compute(double amt){ return amt * 0.20; } },
  REDUCED { double compute(double amt){ return amt * 0.10; } },
  ZERO { double compute(double amt){ return 0.0; } };
  abstract double compute(double amt);
}
```

## 8. Performance & Collections
`EnumSet` is a bit vector internally (fast operations). `EnumMap` uses array indexing—faster & leaner than `HashMap` for enum keys.

## 9. Pitfalls
| Pitfall | Issue | Fix |
|---------|-------|-----|
| Persisting ordinal | Breaks when order changes | Persist name or custom code |
| Mutable fields | Unexpected shared state mutation | Keep immutable / final |
| Overloaded with unrelated logic | Low cohesion | Split into multiple enums |
| Using strings instead | No compile-time safety | Replace with enum |
| Silent invalid parse | Using valueOf without handling | Provide safe wrapper |

## 10. Mini Practice
1. Add a new enum for severity levels (INFO/WARN/ERROR) with color codes.  
2. Implement `EnumSet` of workdays.  
3. Add a `description()` abstract method to `Operation`.  
4. Create a mapping from `Day` to opening hours using `EnumMap`.  
5. Write a safe parser returning Optional<Day>.  

## 11. Key Takeaways
Enums provide type-safe, self-documenting sets of constants with optional behavior. Prefer them over primitive constants for clarity, safety, and extensibility.

See `L42_enums/EnumsDemo.java` for runnable examples.
