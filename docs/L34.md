# L34 - Packages & Imports

Source: folder `L34_Packages/`

## 1. What Is a Package?
A namespace that groups related classes / interfaces, helps avoid name clashes, and controls visibility (package-private access). Physical mapping: `package a.b.c;` expects file path `a/b/c/ClassName.java` (relative to a source root).

In this lesson we prepended `L34_Packages.` to keep the folder self-contained inside the single-folder project.

## 2. Declaring a Package
First non-comment line:
```java
package com.example.util;
```
All types in the file belong to that package.

## 3. Import Forms
| Form | Example | Purpose |
|------|---------|---------|
| Single type | `import a.b.C;` | Bring one class into simple name scope |
| On-demand (wildcard) | `import a.b.*;` | All public types of a package (no subpackages) |
| Static single | `import static a.b.C.method;` | Use static member without qualifying class |
| Static on-demand | `import static a.b.C.*;` | All public static members |

Imports do not incur runtime cost; they are compile-time conveniences. Fully qualified name always works without import.

## 4. Demo Structure
```
L34_Packages/
  com/example/math/Calculator.java
  com/example/util/StringUtils.java
  demo/DemoImports.java
```
Packages declared with `package L34_Packages.com.example.math;` to reflect nested folder prefix.

## 5. Package Rules & Conventions
- Lowercase, dot-separated identifiers.
- Reverse domain name pattern (`com.company.project.module`).
- One public top-level class per file (file name matches class name).
- Types without modifier = package-private visibility.
- Subpackages are independent (com.a != com.a.b).
- Avoid using default (no) package for real projects.

## 6. Access Control & Packages
Package-private (no modifier) members visible only inside same package. Use packages to group cohesive, collaborating types.

## 7. Static Imports
Use sparingly for constants or utility methods (e.g., `import static java.lang.Math.*;`). Avoid large unqualified namespaces that reduce readability.

## 8. Best Practices
| Topic | Guidance |
|-------|----------|
| Naming | All lowercase, no underscores |
| Granularity | Balance: not 1 class per package, not gigantic catch‑all |
| API boundary | Expose minimal public surface; keep internals package-private |
| Wildcard imports | Generally avoid in library code; okay in small examples/tests |
| Static imports | Reserve for well-known constants/methods (e.g., assertions, math) |
| Consistency | Mirror directory and package names exactly |

## 9. Compilation Tip
When compiling manually:
```pwsh
javac L34_Packages\**\*.java
java L34_Packages.demo.DemoImports
```
(Or compile all `javac *.java L34_Packages\**\*.java` but ensure relative root.)

## 10. Common Pitfalls
| Pitfall | Issue | Fix |
|---------|------|-----|
| Mismatched path/package | ClassNotFound / compile error | Align folder path & package declaration |
| Default package usage | Hard to import from packaged code | Always declare a package in larger projects |
| Overusing wildcard imports | Name clashes, readability loss | Prefer explicit imports |
| Static import overuse | Unclear origin of methods | Limit to a few common utilities |
| Subpackage assumption | Think com.a sees com.a.b members | Each package isolated |

## 11. Mini Practice
1. Add a new package `L34_Packages.com.example.model` with a `User` class and import it in `DemoImports`.
2. Introduce a constant in `Calculator` and static import it.
3. Deliberately break a package path then fix it.
4. Replace wildcard imports with explicit imports and compare readability.
5. Add a package-private helper class and show it’s inaccessible from another package.

## 12. Key Takeaways
Packages organize code, manage visibility, and prevent naming conflicts. Keep naming consistent, avoid default package, and use imports to keep code readable without sacrificing clarity.

Run `DemoImports` to see import variants in action.
