# L21 Arrays

Covers Java arrays: declaration, allocation, initialization, iteration patterns, core utility operations (copy, fill, sort, search, compare), multidimensional & jagged arrays, defensive copying, and common pitfalls.

## 1. What Is an Array?
A fixed-length, indexed sequence of elements of a single type stored contiguously (for primitives) or as references (for objects). Length is immutable after creation.

## 2. Declaration & Allocation
```java
int[] nums;              // declaration (no elements yet)
nums = new int[5];       // allocation (all zeros)
String[] names = {"Ann","Bob"}; // literal shorthand
```
Default values:
- numeric primitives: 0 / 0.0
- char: '\u0000'
- boolean: false
- references: null

## 3. Indexing & Bounds
Valid indexes: 0 .. length-1. Access outside throws ArrayIndexOutOfBoundsException immediately (runtime check). Always use `arr.length` instead of hard-coding.

## 4. Iteration Patterns
```java
// Classic for
for (int i = 0; i < nums.length; i++) { use(nums[i]); }
// Enhanced for-each (read-only)
for (int n : nums) { use(n); }
// While
int i = 0; while (i < nums.length) { use(nums[i]); i++; }
// Reverse
for (int i = nums.length - 1; i >= 0; i--) { use(nums[i]); }
// Two indices (palindrome / symmetric checks)
for (int a = 0, b = nums.length - 1; a < b; a++, b--) { /* compare nums[a], nums[b] */ }
```
Choose enhanced for for simple traversal; classic for when you need the index or to modify in place.

## 5. Core Utility Methods (java.util.Arrays)
| Action | Method | Notes |
|--------|-------|-------|
| Copy same length | `clone()` | Shallow copy (OK for primitives) |
| Copy w/ new length | `copyOf(arr,n)` | Pads with defaults if n > length |
| Range copy | `copyOfRange(arr,a,b)` | End index exclusive |
| Bulk fill | `fill(arr, val)` | Overwrites all elements |
| Sort | `sort(arr)` | Dual-pivot quicksort (primitives) |
| Binary search | `binarySearch(arr,val)` | Array must be sorted |
| Equality | `equals(a,b)` | Element-wise |
| Deep equality (nested) | `deepEquals(a,b)` | For arrays of arrays |
| To string | `toString(arr)` | Human-readable |
| Deep to string | `deepToString(nested)` | For multi-d arrays |
| Stream | `Arrays.stream(arr)` | IntStream helpers |

## 6. Searching
- Linear search: O(n); works unsorted.
- Binary search: O(log n); requires sorted order.
Return index (>=0) if found; binarySearch returns (-(insertionPoint) - 1) if not found.

## 7. Multidimensional & Jagged
Java uses arrays-of-arrays:
```java
int[][] grid = new int[2][3];      // rectangular
int[][] jagged = new int[3][];     // outer only
jagged[0] = new int[1];
jagged[1] = new int[2];
jagged[2] = new int[4];
```
Use `deepToString` / `deepEquals` for nested structures.

## 8. Defensive Copying
Expose copies, not internal arrays, to prevent external mutation:
```java
private int[] scores = {1,2,3};
public int[] getScores() { return scores.clone(); }
```

## 9. Common Pitfalls
| Pitfall | Issue | Fix |
|---------|------|-----|
| Off-by-one | Using <= length | Use < length |
| Hard-coded size | Magic numbers | Use arr.length |
| Sharing unintentionally | Assigning same ref | Use clone / copyOf |
| Forget bounds check | Access length index | Last index is length-1 |
| Sorting objects w/ nulls | NPE or order issues | Filter or handle nulls |
| Mutating while iterating enhanced for with size changes | Not allowed for arrays (size fixed) | Use index loop if needed |

## 10. Performance Notes
- Access is O(1) (index math). 
- clone() is very fast (native). 
- Avoid repeatedly resizing: arrays are fixed; use ArrayList for dynamic growth.

## 11. When To Use Array vs List
Use array when:
- Fixed size known up front
- Performance-critical primitive storage
Use List (e.g. ArrayList) when:
- Need dynamic resizing
- Need rich API (add/remove/contains)

## 12. Mini Practice
1. Implement a method that returns a reversed copy of an int array.
2. Write a binary search manually (iterative) without using Arrays.binarySearch.
3. Create a jagged 3x (1..n) triangle and print it.
4. Defensive copy a `char[] password` before hashing.
5. Sum only even numbers using enhanced for.

## 13. Key Takeaways
Arrays are fixed-size, zero-indexed, and fast. Use the `Arrays` utility class for common tasks, prefer enhanced for for simple reading, and guard against out-of-bounds and unintended aliasing.

See `L21_arrays/ArraysDemo.java` to run the examples.
