# L31 - Classes & Instantiation

Source: `L31_classes/ClassesDemo.java`

## 1. What Is a Class?
A blueprint that defines a reference type: fields (state) + methods (behavior). Instances (objects) carry their own field values; methods operate on those values.

## 2. Basic Components
- Fields: variables inside a class (instance vs static).
- Methods: functions inside a class; can access fields.
- Constructors: special methods (no return type, same name as class) used to initialize new objects.
- Static members: belong to the class, not any one instance.
- Instance members: each object has its own copy (for fields) / context (`this`).

## 3. Instantiation Flow
`new ClassName(args)` steps:
1. Class is loaded (if not already) by a ClassLoader.
2. Static initializers run once (static field initializers + static blocks).
3. Memory allocated for the object; fields set to default values.
4. Field initializers and instance initializers run.
5. Constructor body executes.
6. Reference to fully constructed object is returned.

## 4. Constructors
- Overloading: multiple constructors with different parameter lists.
- Delegation: call another constructor using `this(...)` as first line.
- Default constructor: added automatically if you declare no constructors.
- No return type (not even void).
- Use factory methods (`static` returning instance) for expressive names or caching.

## 5. Static vs Instance
| Aspect | Instance | Static |
|--------|----------|--------|
| Belongs to | Object | Class |
| Access needs | Reference | Class name (or ref) |
| Memory | Per object | One copy |
| Typical use | Object state | Shared constants, utilities, counters |

## 6. Nested Class Types
| Type | Definition | Needs Outer Instance? | Use Case |
|------|------------|-----------------------|----------|
| Inner (non-static) | Defined inside class without static | Yes | Access outer state directly |
| Static nested | static class inside | No | Group helper types logically |
| Local class | Declared inside a method | Captures effectively final vars | Short-lived helper |
| Anonymous class | Expression implementing/overriding | Captures effectively final vars | One-off override |
| (Record) | `record Name(...)` (Java 16+) | No | Immutable data carrier |

## 7. Encapsulation
Keep fields private; expose getters/setters for controlled access and validation. Reduces coupling and preserves invariants.

## 8. Immutability (Preview)
Make class immutable by: declaring fields `private final`, setting them in constructor, no setters, defensive copies for mutable inputs (later lesson elaborates).

## 9. Static Initialization
Executed once per class load. Order: static fields (in declaration order) + static blocks top-to-bottom. Avoid heavy I/O in static blocks (can slow class load). Prefer lazy initialization when possible.

## 10. Class Loading Overview
- Bootstrap loader loads core JDK classes.
- Platform / application loaders load library and app classes.
- Lazy: a class loads upon first active use (instantiation, static access, reflection).
- Each loaded class has a unique identity = (ClassLoader + fully qualified name).
- Same class bytes loaded by two loaders -> treated as distinct types.

## 11. Object Creation Cost
Object allocation is typically cheap (pointer bump) in modern JVMs; premature pooling is an anti-pattern. Focus on clarity first.

## 12. Final Fields
Must be assigned exactly once (in field initializer or constructor). Provide thread-safety guarantees (visibility) after construction (details in concurrency lessons).

## 13. toString, equals, hashCode
Override toString for readable debugging; equals/hashCode for logical equality (will appear in next object-focused lesson). Person example overrides toString only.

## 14. Factory Methods vs Constructors
| Constructors | Factory Methods |
|--------------|-----------------|
| Fixed name (class name) | Can choose descriptive name |
| Always creates new instance | May cache / reuse |
| Cannot change return type | Can return subtype |
| Hard to signal variants | Easy to spell variants (e.g. `of`, `from`, `create`) |

## 15. Mini Practice
1. Add an email field with validation in setter (reject missing '@').
2. Create an immutable `Point` class (two final ints, no setters).
3. Add a static counter to track number of `Point` objects created.
4. Write a factory `Person.createAdult(name)` that sets age 18.
5. Add a local class inside `main` that formats a Person as JSON.

## 16. Common Pitfalls
| Pitfall | Issue | Fix |
|---------|-------|-----|
| Missing encapsulation | Public mutable fields | Make private + accessors |
| Recursive constructor call | this() calling itself indirectly | Ensure delegation terminates |
| Heavy static block | Slow start or errors | Defer with lazy init |
| Uninitialized field use | Logic before proper set | Initialize or validate early |
| Leaking this in constructor | Passing this to other objects before fully built | Avoid publishing until end |

## 17. Key Takeaways
Classes bundle state + behavior. Understand the lifecycle: load → init statics → allocate → initialize → constructor. Use encapsulation, prefer clear constructors or factories, and choose nested class forms intentionally.

See `L31_classes/ClassesDemo.java` for runnable demonstrations.
