# L12 - Switch (Traditional & Modern)

Source: `L12_conditionals_switch/ConditionalsSwitch.java`

## Purpose
Select among discrete constant values. Modern switch expressions (Java 14+) return a value and avoid fall-through.

## Styles
- Traditional statement with case + break.
- Arrow switch expression (multi-label, no break).
- Block + yield for multi-statement value.
- Pattern matching for type cases, including guarded patterns with `when` (Java 21).

## When to Use
Many discrete values, enums, mapping to computed values. Prefer if/else for range or compound boolean logic.

## Best Practices
Use arrow form to avoid accidental fall-through, group labels with commas, handle invalid input via default or exhaustiveness (enums), keep side effects minimal.

## Pitfalls
Missing break (classic), duplicate logic, omitted default, overusing switch for simple binary decisions.

## Mini Practice
- Convert classic switch to arrow style.
- Add leap year to month days.
- Enum priority to weight mapping.
- Pattern matching demonstration for String / Integer / other.
- Add a guarded pattern with `when` to treat long strings differently from short ones.

## Guarded Pattern Examples
In `ConditionalsSwitch.java` see the section with guarded patterns:

```
Object any = "hello world";
String desc = switch (any) {
	case String s when s.isBlank() -> "blank string";
	case String s when s.length() > 5 -> "long string (len=" + s.length() + ")";
	case String s -> "short string (len=" + s.length() + ")";
	case Integer i when i % 2 == 0 -> "even int: " + i;
	case Integer i -> "odd int: " + i;
	default -> "other";
};
```

Notes:
- Order matters. Put more specific guards before broader matches.
- Guards refine a successful type test; they donâ€™t change case ordering.
- Keep guards side-effect free and fast to evaluate.

## Takeaway
Modern switch is concise and safer; choose it for mapping discrete inputs to outputs cleanly.
