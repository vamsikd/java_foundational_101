# L39 - Abstract Classes

Source: `L39_abstract_classes/AbstractClassesDemo.java`

## 1. Definition
An abstract class is a class that cannot be instantiated and may contain abstract methods (methods without bodies) alongside concrete members. It defines a partial implementation and a common contract for subclasses.

## 2. When to Use
| Scenario | Abstract Class Fit | Why |
|----------|--------------------|-----|
| Share state + behavior across related types | Yes | Can hold fields + partial methods |
| Provide common constructor logic | Yes | Constructors allowed |
| Need multiple inheritance of behavior | No (Java lacks it) | Use interfaces for additional contracts |
| Want to force method implementation | Yes | Abstract methods require overrides |
| Pure capability contract (no state) | Prefer interface | Simpler & more flexible |

## 3. Core Features
| Aspect | Abstract Class | Interface (contrast) |
|--------|----------------|----------------------|
| Instantiation | Not allowed | Not allowed |
| Constructors | Allowed | Not allowed (no instance) |
| Fields | Yes (any visibility) | public static final constants only (until Java 8 default methods—still constants) |
| State | Yes | No instance state |
| Multiple inheritance | Single abstract superclass | Multiple interfaces implementable |
| Access modifiers | Full range on members | Methods implicitly public (unless default/private in modern Java) |
| Abstract methods | Yes | Yes |
| Concrete methods | Yes | Yes (default / static in interfaces) |

## 4. Typical Use Cases
| Use Case | Example |
|----------|---------|
| Template method pattern | `ReportGenerator.generate()` final + hook methods |
| Hierarchy root with shared logic | `Shape` computing area variants |
| Partial implementation | `TwoDShape` providing helper utilities |
| Ensuring minimal method set | Abstract base demands overrides |

## 5. Rules
1. At least one abstract method OR declared abstract intentionally (can be empty but rare).  
2. Class with any abstract method must be declared `abstract`.  
3. Abstract methods cannot be `final`, `private`, or `static` (static cannot be overridden; private not visible; final prevents override).  
4. Constructors may exist (called during subclass instantiation).  
5. A subclass must implement all inherited abstract methods or be abstract itself.  
6. Abstract class can implement interfaces and selectively implement their methods.  
7. Fields follow normal access rules; prefer `protected` sparingly (favor private + protected getters).  

## 6. Best Practices
| Practice | Benefit |
|----------|---------|
| Keep abstract base small & cohesive | Reduces fragile inheritance |
| Provide protected helper methods for reuse | Avoids duplication in subclasses |
| Use final template method + abstract hooks for algorithms | Consistent orchestration |
| Favor composition or interfaces if deep hierarchy emerges | Flexibility & testability |
| Minimize mutable protected fields | Prevents subclass coupling |
| Document extension points clearly | Guides maintainers |

## 7. Template Method Pattern
A `final` public method defines the algorithm steps; abstract/protected methods supply configurable steps.
```java
abstract class Processor {
    public final void run() { step1(); step2(); }
    protected abstract void step1();
    protected abstract void step2();
}
```

## 8. Abstract vs Interface Decision Flow
1. Need to share code/state? → Abstract class.
2. Only a contract, multiple implementations? → Interface.
3. Need multiple orthogonal capabilities? → Compose interfaces + (optionally) 1 abstract base for shared core.
4. Expect future method additions? → Interface default methods can help maintain compatibility.

## 9. Pitfalls
| Pitfall | Issue | Fix |
|---------|-------|-----|
| Deep inheritance chains | Hard to reason & extend | Flatten with composition |
| Overusing protected fields | Tight coupling | Keep state private + accessors |
| Abstract class with unrelated responsibilities | Low cohesion | Split into focused abstractions |
| Subclass forgetting to call super constructor logic | Invariant break | Use final template or enforce through constructor args |
| Exposing partially initialized this in constructor | Subclass misuse | Avoid calling overridable methods in constructors |

## 10. Mini Practice
1. Add a new `Square` subclass of `Shape` using one side length.  
2. Add a new export format implementing `ReportGenerator` hooks.  
3. Modify `TwoDShape` to include a `description()` abstract method and implement in subclasses.  
4. Refactor a class hierarchy where only one method differs—apply template pattern.  
5. Convert an interface with state needs into an abstract base.  

## 11. Key Takeaways
Abstract classes let you share state + behavior and define extension points via abstract methods. Use them when you need partial implementation plus enforced contracts; otherwise prefer interfaces for simple capability definitions.

```java
abstract class Animal { abstract void speak(); }
class Dog extends Animal { void speak() { System.out.println("Woof"); } }
```

See code in `L39_abstract_classes/AbstractClassesDemo.java` for demonstrations.
