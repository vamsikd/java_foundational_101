# L52 - Checked vs Unchecked Exceptions

Source: `L52_checked_unchecked/CheckedUncheckedDemo.java`

## 1. Exception Hierarchy
```
Throwable
 ├─ Error (serious JVM problems; don't catch)
 └─ Exception
     ├─ RuntimeException (unchecked)
     │    e.g., NullPointerException, IllegalArgumentException, IllegalStateException
     └─ (checked) e.g., IOException, SQLException
```

## 2. Checked vs Unchecked
| Aspect | Checked | Unchecked |
|--------|--------|-----------|
| Compile requirement | Must be declared or caught | No declaration needed |
| Typical use | Recoverable conditions (I/O, network) | Programming errors, precondition violations |
| Propagation | Verbose (throws/try-catch) | Lightweight |
| API design | Signals caller to handle | Caller may handle or let bubble |

## 3. Uses & Use Cases
- Use checked when caller can reasonably recover or retry (file not found, network timeout).  
- Use unchecked for argument validation and programmer mistakes (nulls, index out of bounds).  
- Wrap low-level checked exceptions at module boundaries into domain-specific unchecked to avoid leaking infrastructure concerns.  

## 4. Rules
1. Do not use exceptions for normal control flow.  
2. Declare only the specific checked exceptions you actually throw.  
3. Convert checked to unchecked at boundaries if it simplifies API without losing context (preserve cause).  
4. Never catch Exception broadly unless rethrowing or logging; narrow catches first.  
5. Include context in messages; avoid leaking secrets.  
6. Prefer IllegalArgumentException/IllegalStateException for validation/state errors.  

## 5. Best Practices
| Practice | Benefit |
|----------|---------|
| Use try-with-resources for I/O | Ensures cleanup |
| Wrap and rethrow with domain types | Clear layers, better diagnostics |
| Provide retry guidance in messages | Operability |
| Keep exception hierarchies shallow | Simplicity |
| Document checked exceptions in Javadoc | Caller clarity |

## 6. Examples in Code
- `unsafeDivide` throws `ArithmeticException` (unchecked).  
- `sizeOf` declares `throws IOException` (checked).  
- `repositorySave` wraps `IOException` into `RepositoryException` (unchecked).  
- `requirePositive` validates inputs using `IllegalArgumentException`.  

## 7. Pitfalls
| Pitfall | Issue | Fix |
|---------|-------|-----|
| Declaring overly broad throws | Pushes burden to callers | Declare specific exceptions |
| Swallowing checked exceptions | Lost error context | Log + rethrow/wrap |
| Overusing checked | Boilerplate | Prefer unchecked for programmer errors |
| Ignoring unchecked | Crashes | Validate inputs early |

## 8. Mini Practice
1. Change `sizeOf` to try-with-resources reading first line and handle `IOException`.  
2. Add a custom checked `RepositoryCheckedException` and demonstrate throws/handle.  
3. Add a validator that throws `NullPointerException` when argument is null (document it).  
4. Propagate a checked exception through multiple layers and wrap at the boundary.  

## 9. Key Takeaways
Use checked for recoverable scenarios that the caller should handle; use unchecked for programming errors and validation. Preserve causes, keep messages actionable, and avoid broad catches.

See `L52_checked_unchecked/CheckedUncheckedDemo.java` for runnable examples.
