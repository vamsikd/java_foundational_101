# L37 - The `final` Keyword

Source: `L37_final_keyword/FinalKeywordDemo.java`

## 1. Definition
`final` means "cannot be changed" in the specific context applied:
- Variable / Field: cannot be reassigned after its first (and only) assignment.
- Method: cannot be overridden in subclasses.
- Class: cannot be subclassed.
- Parameter: cannot be reassigned within the method.

It enforces immutability of the reference (not necessarily the object) or prevents further inheritance/overriding.

## 2. Use Cases
| Context | Example | Intent |
|---------|---------|-------|
| Constant field | `public static final int MAX = 100;` | Shared constant value |
| Immutable object state | `private final int x;` | Guarantees per-instance value stability |
| Method locking | `public final void process()` | Prevent alteration of template logic |
| Class sealing | `public final class String` | Enforce design, security, performance |
| Parameter | `void set(final int v)` | Prevent accidental reassignment inside method |
| Local var (effectively final) | used in lambda | Lambda capture requirement |

## 3. Rules
1. A final local variable must be assigned exactly once.  
2. A blank final field (non-static or static) must be assigned in its constructor (instance) or static block (static) before use.  
3. Final reference variables cannot point to a different object after assignment, but the referenced object may still mutate (if mutable).  
4. A final method cannot be overridden; attempting to do so causes a compile error.  
5. A final class cannot be subclassed.  
6. Final + primitive = value cannot change; Final + immutable object (e.g., String, record) = fully immutable semantics; Final + mutable object = only reference is stable.  
7. "Effectively final" variables (not reassigned) can be captured by lambdas/anonymous classes even if `final` keyword omitted.  
8. Avoid cyclic dependency in constructors when initializing final fields—must complete assignment.  
9. Final fields enable safe publication without synchronization (visibility guarantees after construction).  

## 4. Best Practices & Guidelines
| Guideline | Rationale |
|-----------|-----------|
| Prefer immutability: make fields `private final` whenever possible | Reduces bugs, simplifies reasoning |
| Use `public static final` for true constants only (literals) | Avoid exposing mutable internals |
| Keep constant names UPPER_SNAKE_CASE | Convention clarity |
| Avoid "constant classes" that are grab-bags | Group constants by domain/context |
| Use final in method parameters sparingly | Readability vs marginal safety gain |
| Don't mark everything final blindly | Noise can hurt readability |
| Document why a class is final if non-obvious | Aids maintainers |
| Combine with defensive copies for collections | Prevent external mutation |

## 5. Immutability Patterns
- All fields `private final`.
- No setters; provide getters or constructor parameters.
- For collections: wrap unmodifiable (`List.copyOf`, `Collections.unmodifiableList`).
- Validate constructor arguments up front.

## 6. Blank Finals
```java
class Config {
    private final int port;      // blank final
    private static final String MODE; // static blank final
    static { MODE = System.getProperty("mode", "DEV"); }
    Config(int port) { this.port = port; }
}
```

## 7. Effectively Final in Lambdas
```java
int factor = 3; // not reassigned later
list.stream().map(x -> x * factor).toList(); // ok: factor is effectively final
```
If you later reassign `factor`, the lambda capture would fail to compile.

## 8. Final Methods & Templates
Use a `final` public method that orchestrates algorithm steps (`template()`), while protected overridable hooks implement variation (`step1`, `step2`). Prevents subclasses from breaking the algorithm's ordering.

## 9. Pitfalls
| Pitfall | Issue | Fix |
|---------|-------|-----|
| Assuming final makes object immutable | Only reference stability guaranteed | Use immutable object or defensive copies |
| Overusing final on every local | Visual clutter | Apply where adds clarity |
| Large constant dump classes | Poor cohesion | Segregate by feature/module |
| Leaking `this` before final fields set | Visibility issues | Complete construction first |
| Using mutable static final collections | Unexpected external mutation | Wrap or expose unmodifiable view |

## 10. Practice
1. Convert a mutable data holder into an immutable class with final fields.  
2. Add a final template method and override only hook steps.  
3. Create a blank final field initialized in constructor and print it.  
4. Try to override a final method (observe compile error).  
5. Use a final vs non-final local variable inside a lambda.  

## 11. Key Takeaways
`final` supports immutability, safe publication, and controlled inheritance. Use it deliberately to lock what must not vary—values, methods, or types—while keeping code readable.

```java
public final class VersionInfo {
    public static final String VERSION = "2.1.0";
    private VersionInfo() {}
}
```

See `L37_final_keyword/FinalKeywordDemo.java` for examples.
