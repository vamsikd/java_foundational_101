# L33 - Inheritance & Overriding

Source: `L33_inheritance/InheritanceDemo.java`

## 1. Purpose
Reuse and specialization: a subclass extends a superclass, inheriting accessible fields/methods and optionally overriding behavior.

## 2. Key Terms
- Superclass (parent / base) – the class being extended.
- Subclass (child / derived) – extending class adding or refining behavior.
- Single inheritance – Java classes extend exactly one direct superclass.
- Polymorphism – a superclass reference can hold subclass objects; overridden method chosen at runtime (dynamic dispatch).

## 3. Basic Example
```java
Animal a = new Dog("Rex");
a.speak(); // Dog's override
```

## 4. this vs super
| Keyword | Refers To | Typical Use |
|---------|-----------|-------------|
| this | Current object | Access members, pass reference |
| super | Immediate superclass | Invoke overridden method or constructor |

Example:
```java
@Override
public void play() {
  System.out.println(getName()+" (GoldenRetriever) starts play");
  super.play(); // call Dog.play
  System.out.println(getName()+" (GoldenRetriever) ends play");
}
```

## 5. Constructor Chaining
First statement of a constructor may call `super(args)` or another `this(args)`. If omitted, Java inserts `super()` (no-arg). Chain ensures superclass state initializes first.

## 6. Multi-Level Inheritance
`GoldenRetriever extends Dog extends Animal` – each layer can override methods; the most specific override wins at call site.

Call resolution search path: actual object's class → parent → … → Object.

## 7. Overriding Rules
- Signature must match (name + parameters) & compatible return type (covariant allowed for object returns).
- Access cannot be more restrictive (can widen).
- Throws clause can narrow (fewer / more specific checked exceptions).
- Use `@Override` annotation to catch mistakes.

## 8. When to Call super.method()
Call when you want to extend, not replace, parent behavior. Skip if replacing entirely.

## 9. Polymorphism Demo
Looping over an array of `Animal` resolves each `speak()` to the actual subclass implementation at runtime (dynamic dispatch).

## 10. Abstract Classes
Define an abstract superclass with abstract methods forcing subclasses to implement.
```java
abstract class Shape { abstract double area(); }
```
Cannot instantiate abstract classes directly.

## 11. Template Method Pattern (Preview)
A `final` method in abstract class calls abstract method steps; subclasses override steps but not algorithm skeleton (`printArea()` calling `area()`).

## 12. Object Class
All classes extend `Object` implicitly. Common methods: `toString`, `equals`, `hashCode`, `getClass`. Overriding `toString` improves debugging.

## 13. instanceof (Pattern Matching)
```java
if (obj instanceof Dog d) { d.fetchStick(); }
```
Pattern matching (Java 16+) binds a variable of target type if test passes.

## 14. Composition vs Inheritance
Prefer composition when relationship is "has-a" or you only need a small part of functionality; inheritance for clear "is-a" relationships with stable base behavior.

## 15. Common Pitfalls
| Pitfall | Issue | Fix |
|---------|------|-----|
| Overuse of inheritance | Rigid hierarchies | Favor composition |
| Forgotten @Override | Silent overload instead | Add annotation |
| Calling overridable method in constructor | Uses uninitialized subclass state | Avoid or mark methods final |
| Name hiding (fields) | Confusing shadowing | Use different names |
| Deep chains | Hard to trace | Keep shallow; refactor |

## 16. Mini Practice
1. Add a `Bird` subclass with overridden `speak()` and new `fly()` method.
2. Add an `abstract double perimeter()` to `Shape` and implement in `Circle`.
3. Create a `final` subclass and attempt extension (observe compile error).
4. Demonstrate composition: create `Pet` class that holds an `Animal` instead of extending it.
5. Implement `toString()` for `Cat` and `Dog` calling `super.toString()`.

## 17. Key Takeaways
Inheritance enables reuse + polymorphism; use for genuine "is-a" relationships. Override carefully with @Override, call `super` only when extending behavior, and consider composition to avoid brittle hierarchies.

See `L33_inheritance/InheritanceDemo.java` for runnable examples.
