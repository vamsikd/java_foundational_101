# L32 - Encapsulation

Source: `L32_encapsulation/EncapsulationDemo.java`

## 1. Concept
Encapsulation bundles data + behavior and hides internal representation. Protects invariants, allows evolution of implementation without breaking callers.

## 2. Dimensions of Encapsulation
| Dimension | Technique | Example |
|-----------|-----------|---------|
| Access control | private / protected / (package) / public | `private String email;` |
| Mutability control | final fields / no setters | `final int x;` |
| Representation hiding | defensive copies, unmodifiable views | `return secret.clone();` |
| Initialization control | constructors, factories, builders | `new UserAccount(...)` |
| Lazy evaluation | compute-once cache | `if(cached==null)` |
| Invariant enforcement | validation in setters/constructors | `if(!email.contains("@"))` |

## 3. Access Modifiers (Quick Reference)
| Modifier | Visibility |
|----------|------------|
| private | Declaring class only |
| (package-private) | Same package (default when omitted) |
| protected | Package + subclasses (even in other packages via inheritance) |
| public | Everywhere |

## 4. Getters & Setters
Provide controlled access. Favor meaningful methods over trivial pass-through when adding logic.
```java
public String getEmail() { return email; }
public void setEmail(String email) {
    if(email == null || !email.contains("@")) return; // guard
    this.email = email;
}
```
Avoid exposing setters for fields that should not change (make field `final`).

## 5. Read-Only vs Write Access
- Read-only: expose getter only.
- Computed: expose method computing value (e.g., `length()`), not raw internal structure.
- Write-limited: provide controlled mutator with validation.

## 6. Defensive Copying
Prevent callers from mutating internal mutable state.
```java
class SecretHolder {
  private final char[] secret;
  SecretHolder(char[] secret){ this.secret = secret.clone(); }
  char[] getSecret(){ return secret.clone(); }
}
```
Never return internal mutable arrays or collections directly (later: use `List.copyOf`).

## 7. Lazy Initialization
Defer expensive setup until first use. Cache result afterward.
```java
if(cached == null) {
  cached = compute();
}
return cached;
```
Keep lazy logic simple; complex synchronization belongs in advanced topics.

## 8. Immutability Variant
Make objects immutable when possible: private final fields, set via constructor, no setters, defensive copies for inputs. Simpler reasoning + thread-safety benefits.

## 9. Protected & Package-Private
- protected: subclass hooks (e.g., allow extending behavior). Use sparingly; prefer composition + private.
- package-private: collaborate within package without exposing publicly.

## 10. Builders
Encapsulate construction of complex objects; separates validation from usage.
```java
BuiltUser u = new BuiltUser.Builder().username("a").email("a@x").build();
```
When field count small + simple: constructors are fine; avoid gratuitous builders.

## 11. Fluent Setters
Return `this` to chain configuration. Keep for config-like objects, not domain entities unless it adds clarity.

## 12. Use Cases & Benefits
| Goal | Encapsulation Benefit |
|------|-----------------------|
| Validation | Block invalid states early |
| Evolution | Change internals w/o breaking API |
| Security | Prevent unauthorized mutation |
| Concurrency | Control synchronization boundaries |
| Maintainability | Clear contract surface |

## 13. Common Pitfalls
| Pitfall | Issue | Fix |
|---------|------|-----|
| Exposing mutable internals | Callers mutate unexpectedly | Return copies / unmodifiable |
| Over-encapsulation | Boilerplate w/o value | Only add accessors when needed |
| Trivial getters/setters | Noise | Consider public final field (for pure data carriers) or records |
| Inconsistent validation | Some setters validate, others not | Centralize checks |
| Leaking this in constructor | Escape before fully built | Finish init before publishing |

## 14. Mini Practice
1. Add password hash field with private setter; expose `changePassword(raw)` doing hash.
2. Add method returning defensive copy of internal int array.
3. Convert a mutable config to immutable using a builder.
4. Replace trivial setters with a constructor parameter.
5. Introduce lazy-loaded description string built from other fields.

## 15. Key Takeaways
Encapsulation shields invariants and lets implementations evolve. Use the smallest visibility, validate at boundaries, favor immutability and defensive copies for safety.

See `L32_encapsulation/EncapsulationDemo.java` for runnable examples.
