# L40 - Inner Classes & Anonymous Inner Classes

Source: `L40_inner_classes/InnerClassesDemo.java`

## 1. Definition
Inner classes are classes defined within another class or within a code block. Java has several forms:
- Member (non-static) inner class: associated with an instance; can access outer instance members directly.
- Static nested class: declared static; no implicit outer instance reference.
- Local class: declared within a method/block; scope limited to that block.
- Anonymous inner class: expression that defines an unnamed class and instantiates it immediately (usually implementing an interface or extending a class once).

## 2. Use Cases
| Type | Use Case | Rationale |
|------|----------|-----------|
| Member inner | Tight coupling to outer instance (e.g., iterator) | Needs outer state |
| Static nested | Helper grouping without polluting package | Namespacing, no outer state |
| Local class | Short-lived algorithm-specific helper | Keeps detail near usage |
| Anonymous inner | One-off override / callback | Inline behavior customization |

## 3. Rules
1. Member inner class instance requires an outer instance: `Outer outer = new Outer(); Outer.MemberInner mi = outer.new MemberInner();`  
2. Static nested class is like a normal top-level class but namespaced: `new Outer.StaticNested()` without an outer instance.  
3. Local & anonymous classes can access effectively-final local variables from enclosing scope.  
4. Anonymous inner class cannot declare explicit constructors; initializer blocks or instance field initializers can run setup.  
5. Inner classes compile to synthetic names (`Outer$MemberInner.class`).  
6. Avoid referencing `this` ambiguously—use `Outer.this` for clarity inside member inner classes.  
7. Functional interfaces favor lambdas over anonymous classes when only one abstract method.  

## 4. Best Practices
| Practice | Benefit |
|----------|---------|
| Prefer static nested if no outer instance needed | Avoids hidden outer reference & memory leak risk |
| Keep inner classes small and cohesive | Readability |
| Use lambdas instead of anonymous classes for functional interfaces | Brevity & clarity |
| Limit local/anonymous classes to very localized logic | Prevents clutter |
| Name member inner classes meaningfully (e.g., `IteratorImpl`) | Self-documenting |
| Avoid deep nesting levels (>2) | Maintainability |
| Consider top-level class if reused across multiple outers | Reusability |

## 5. Memory & Lifetime Considerations
- Member inner instances hold implicit reference to outer -> may prevent GC if retained elsewhere.  
- Static nested avoids this reference; safer for caches & long-lived utilities.  
- Local/anonymous classes can't be referenced outside their block; good for scoping.  

## 6. Anonymous Inner vs Lambda
| Aspect | Anonymous Inner | Lambda |
|--------|-----------------|--------|
| Syntax | Verbose (override method) | Concise |
| this reference | Refers to anonymous instance | Refers to enclosing instance |
| Multiple methods | Can override multiple (if subclass) | Single abstract method only |
| Use case | Need extra fields or multiple overrides | Simple functional behavior |

## 7. Example Snapshot
```java
Outer outer = new Outer("X");
Outer.MemberInner mi = outer.new MemberInner(5);
Outer.StaticNested sn = new Outer.StaticNested("tag");
Runnable r = new Runnable(){ public void run(){ System.out.println("anon"); } };
Action a = msg -> System.out.println(msg); // lambda for functional interface
```

## 8. Pitfalls
| Pitfall | Issue | Fix |
|---------|-------|-----|
| Using member inner when static nested suffices | Unneeded outer ref | Make it static |
| Retaining inner in static context | Memory leak risk | Use static nested or decouple |
| Overusing anonymous classes for simple callbacks | Verbosity | Use lambda |
| Modifying captured local variable | Compile error | Use wrapper/mutable holder |
| Deeply nested local classes | Obscure code | Extract to top-level or reduce nesting |

## 9. Mini Practice
1. Convert a member inner class to static nested and adjust access.  
2. Add a field to an anonymous inner class (requires switching from lambda).  
3. Demonstrate capture of an effectively-final variable in a local class.  
4. Replace an anonymous comparator with a lambda.  
5. Create a leak scenario by storing an inner class in a static list—then fix it.  

## 10. Key Takeaways
Choose the narrowest, leanest nesting form. Use static nested when no outer state is needed, member inner when behavior truly belongs to the instance, local/anonymous for very localized customization, and lambdas for functional single-method interfaces.

See `L40_inner_classes/InnerClassesDemo.java` for runnable variations.
