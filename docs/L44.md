# L44 - Interface Types (Regular, Functional, Marker)

Source: `L44_interface_types/InterfaceTypesDemo.java`

## 1. Definitions
| Type | Description | Example |
|------|-------------|---------|
| Regular Interface | Declares one or more abstract methods (may include default/static) | `Comparable<T>` |
| Functional Interface | Exactly one abstract method (SAM) enabling lambda/method ref use | `Runnable`, `Supplier<T>` |
| Marker Interface | No methods; presence conveys metadata/capability | `Serializable`, `Cloneable` |

## 2. Usage
| Scenario | Type Fit | Reason |
|----------|---------|-------|
| Provide a multi-method contract | Regular | Rich behavior set |
| Plug into a stream/functional pipeline | Functional | Lambda-friendly |
| Tag objects for framework behavior | Marker | Simple classification |
| Compose simple transformations | Functional | Chainable design |
| Capability detection via `instanceof` | Marker | Lightweight check |

## 3. Rules
1. Functional interfaces may have any number of default/static/private methods in addition to the single abstract method.  
2. Use `@FunctionalInterface` to enforce single abstract method at compile time.  
3. Marker interfaces must remain empty; adding a method breaks all implementers.  
4. Prefer enums or annotations when tagging does not require type hierarchy integration.  
5. Regular interfaces can extend multiple interfaces (including functional ones) but adding extra abstract methods breaks functional status.  
6. Lambdas capture effectively-final variables only.  
7. Use method references (`String::trim`) for readability when mapping directly to existing methods.  

## 4. Best Practices
| Practice | Benefit |
|----------|---------|
| Keep functional interface method names verb-like | Clear intent |
| Supply default combinators (`andThen`, `compose`) | Reusability |
| Provide static factory helpers (e.g., `nullSafe`) | Encapsulate patterns |
| Avoid overusing marker interfaces | Favor annotations for richer metadata |
| Document thread-safety expectations | Contract clarity |
| Keep regular interfaces cohesive (ISP) | Maintainability |

## 5. Functional Interface Patterns
```java
@FunctionalInterface
interface Transformer<T> {
  T apply(T in);
  default Transformer<T> andThen(Transformer<T> next){ return v -> next.apply(apply(v)); }
  static <T> Transformer<T> identity(){ return v -> v; }
}
```

## 6. Marker Interface vs Annotation
| Marker Interface | Annotation |
|------------------|-----------|
| Affects type system (`instanceof`) | Metadata only (unless processed) |
| Inheritance-based | Orthogonal to type hierarchy |
| Harder to retrofit across unrelated classes | Can annotate any target |
| Enables polymorphic method overloading | Not directly |

## 7. Lambdas vs Anonymous Classes
| Aspect | Lambda | Anonymous Class |
|--------|--------|-----------------|
| Boilerplate | Minimal | Verbose |
| this reference | Enclosing instance | Anonymous class instance |
| Single method target | Required | Not required (can add more) |
| State via fields | Use captured vars | Can add fields/methods |

## 8. Mini Practice
1. Add a `Filter` functional interface with `and` combinator.  
2. Implement a marker `Auditable` and check with `instanceof`.  
3. Convert an anonymous class to a lambda for `Runnable`.  
4. Create a higher-order method returning a composed `Processor`.  
5. Use a method reference in place of a lambda (`System.out::println`).  

## 9. Pitfalls
| Pitfall | Issue | Fix |
|---------|-------|-----|
| Removing SAM by adding a second abstract method | Breaks lambda usage | Add default implementation or create new interface |
| Overusing marker interfaces | Type bloat | Replace with annotation |
| Side-effects inside lambdas | Hard to reason | Keep lambdas pure when possible |
| Capturing mutable variables | Race/visibility issues | Capture immutable or final copies |

## 10. Key Takeaways
Choose among regular, functional, and marker interfaces based on required behavior richness, lambda integration, and tagging needs. Keep interfaces focused and composable; leverage default methods for reusable utilities without forcing abstract class inheritance.

See `L44_interface_types/InterfaceTypesDemo.java` for runnable examples.
