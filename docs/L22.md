# L22: Java Collections API — interfaces, hierarchy, and use cases

This lesson gives you a practical tour of the core Collections API:
- Collection super-interface and its main subinterfaces: List, Set, Queue/Deque
- Sorted/Navigable variants for order-aware collections
- Map (not a Collection) for key→value associations

## 1) Interfaces & Hierarchy (big picture)
- Collection<E>
  - List<E>: ordered, indexed, duplicates allowed (ArrayList, LinkedList)
  - Set<E>: unique elements (HashSet, LinkedHashSet, TreeSet)
  - Queue<E>: queue semantics (ArrayDeque, LinkedList, PriorityQueue)
    - Deque<E>: double-ended queue (ArrayDeque, LinkedList)
- Map<K,V> (separate from Collection)
  - HashMap, LinkedHashMap, TreeMap

Sorted/Navigable:
- SortedSet / NavigableSet — TreeSet implements both; keeps natural or comparator order
- SortedMap / NavigableMap — TreeMap implements both; ordered by key

## 2) Uses and Use Cases per Implementation
- ArrayList — random access, end-appends; use for most lists
- LinkedList — frequent head/tail inserts/removes, also implements Deque
- HashSet — fast membership checks; no order guarantees
- LinkedHashSet — deduplicates while preserving insertion order
- TreeSet — sorted unique elements; range queries (headSet, tailSet)
- ArrayDeque — fast deque/stack/queue operations; prefer over Stack
- PriorityQueue — best‑first retrieval (min-heap by default)
- HashMap — general purpose map; no order
- LinkedHashMap — preserves insertion order; good for predictable iteration
- TreeMap — sorted keys; range queries (subMap, headMap, tailMap)

## 3) Code Tour
Open `L22_collection_api/CollectionsApiDemo.java` to see:
- List operations (insert, get)
- Set uniqueness and order variants
- Queue/Deque operations (offer/poll/peek; addFirst/addLast)
- Map inserts/gets and entry iteration

## 4) Tips & Gotchas
- Choosing a collection is about operations: access pattern, ordering, duplicates, concurrency.
- Avoid `Vector` and `Stack`; prefer `ArrayList`/`Deque`.
- Be mindful of `null` support differences (e.g., `TreeSet` with natural ordering disallows null in modern JDKs).
- For thread-safe variants, prefer `java.util.concurrent` collections (next concurrency lessons).
- For read-only views use `Collections.unmodifiableList(list)` etc.

## 5) Try it
Compile and run:
```pwsh
javac .\L22_collection_api\CollectionsApiDemo.java
java L22_collection_api.CollectionsApiDemo
```

Expected output (approximate):
```
=== L22: Collections API Demo ===
-- Interfaces & hierarchy --
Collection <- List, Set, Queue
Deque extends Queue
SortedSet / NavigableSet for ordered sets
Map is NOT a Collection; SortedMap / NavigableMap for ordered maps
-- List: ordered, indexed, duplicates allowed --
ArrayList: [alpha, inserted, beta, beta], get(2)=beta
LinkedList: [first, head, mid, tail], removeFirst()=first
-- Set: unique elements, no duplicates --
HashSet (no order, unique): [1, 2, 3]
LinkedHashSet (insertion order): [3, 1, 2]
TreeSet (sorted): [1, 2, 3], first=1
-- Queue & Deque --
ArrayDeque as Queue (FIFO poll): ABC
PriorityQueue (ascending): 1 3 5 
Deque: [1, 2, 4], peekFirst=1, peekLast=4
-- Map: key->value associations (not a Collection) --
HashMap: value of bob = 5, keys=[alice, bob, carol]
LinkedHashMap (insertion order): {z=1, a=2, m=3}
TreeMap (sorted by key): {a=2, m=3, z=1}, firstKey=a
Iterate entries: a=2 m=3 z=1 
=== End of Collections API Demo ===
```

Source: `L22_collection_api/CollectionsApiDemo.java`.
