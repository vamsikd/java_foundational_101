# L43 - Annotations

Source: `L43_annotations/AnnotationsDemo.java`

## 1. Definition
Annotations are metadata attached to program elements (classes, methods, fields, parameters, modules, etc.) that can influence compile-time checks, tooling, code generation, or runtime behavior (via reflection), depending on their retention policy.

## 2. Built-In Common Annotations
| Annotation | Purpose |
|-----------|---------|
| @Override | Compile-time check that a method overrides a superclass/interface method |
| @Deprecated | Marks API as obsolete; compiler warnings on use |
| @SuppressWarnings | Suppress specific compiler warnings |
| @FunctionalInterface | Enforce single abstract method contract |
| @SafeVarargs | Suppress heap pollution warnings for varargs (applies to certain contexts) |
| @Retention / @Target / @Inherited / @Documented / @Repeatable | Meta-annotations defining annotation behavior |

## 3. Retention Policies
| Retention | Meaning | Use Case |
|-----------|---------|---------|
| SOURCE | Discarded after compilation | Pure documentation / tooling (e.g., Lombok) |
| CLASS | In bytecode but not visible at runtime | Framework processing via bytecode tools |
| RUNTIME | Available via reflection at runtime | Dependency injection, runtime processing |

## 4. Targets
`@Target(ElementType.TYPE, METHOD, FIELD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE, RECORD_COMPONENT, etc.)` restricts where an annotation may appear.

## 5. Creating a Custom Annotation
```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@interface Task {
    String name();
    int priority() default 0;
    boolean experimental() default false;
}
```
Attributes (elements) are methods; defaults allowed; must be primitives, String, Class, enum, annotation, or arrays thereof.

## 6. Processing Annotations
- Compile-time: annotation processors (APT / javac) generate code or perform validation.
- Runtime: reflection (`isAnnotationPresent`, `getAnnotation`).

## 7. Repeatable Annotations
Use `@Repeatable(Container.class)` to allow multiple occurrences:
```java
@Retention(RUNTIME) @Target(METHOD)
@Repeatable(Tags.class)
@interface Tag { String value(); }
@interface Tags { Tag[] value(); }
```
Access via `getAnnotationsByType(Tag.class)`.

## 8. Inherited Annotations
`@Inherited` on a class-level annotation allows subclasses to see it via `isAnnotationPresent`. Only applies to class targets (not methods/fields).

## 9. Best Practices
| Practice | Benefit |
|----------|---------|
| Keep annotations declarative (no heavy logic) | Simplifies processing |
| Use RUNTIME only when necessary | Lower overhead |
| Validate required attributes with processors | Early feedback |
| Prefer enums over String literals for attribute options | Type safety |
| Document annotation contract & retention | Consumer clarity |
| Avoid business logic in annotation values | Keep metadata simple |
| Group related annotations into a cohesive package | Organization |

## 10. Pitfalls
| Pitfall | Issue | Fix |
|---------|-------|-----|
| Excess RUNTIME annotations | Reflection overhead | Downgrade to SOURCE/CLASS when possible |
| Using strings for modes | Typos | Use enum attribute |
| Ignoring default retention (CLASS) | Unexpected absence at runtime | Always specify intended retention |
| Overusing @SuppressWarnings | Hides real issues | Apply narrowly & justify |
| Forgetting container for repeatable | Compile error | Provide container annotation |

## 11. Mini Practice
1. Add a `@Severity(level=HIGH)` annotation with enum level and process it.  
2. Create a repeatable `@Role` annotation and attach multiple roles to a class.  
3. Write a runtime scanner that invokes all methods with `@Task(priority>1)`.  
4. Add a SOURCE retention marker and confirm it is absent at runtime.  
5. Create an annotation processor stub (outline) for compile-time validation.  

## 12. Key Takeaways
Annotations add structured metadata; retention + target decide visibility & scope. Use them to declare intent, not to embed logic. Combine with processing (compile-time or runtime) to enable powerful patterns (dependency injection, mapping, validation).

See `L43_annotations/AnnotationsDemo.java` for examples.
